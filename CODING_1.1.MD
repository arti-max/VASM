

# 1. Условные директивы: .IFNDEF, .ENDIF

## Ассемблер теперь поддерживает условную компиляцию с помощью директив `.IFNDEF` (IF Not DEFined) и `.ENDIF`. Эти директивы позволяют включать или исключать фрагменты кода в зависимости от того, определен ли определенный символ (макрос) или нет.
_Синтаксис_
```asm
.IFNDEF <символ>
    ; Код, который будет скомпилирован, если <символ> не определен
    ...
.ENDIF
```
`.IFNDEF <символ>`:
        Проверяет, не определен ли символ.
        Если символ не определен, то компилятор обрабатывает код до директивы `.ENDIF`.
        Если символ уже был определен ранее с помощью директивы .DEFINE, то код до директивы `.ENDIF` будет проигнорирован.
<br>`.ENDIF`:
        Завершает блок условной компиляции, начатый директивой `.IFNDEF`.

_Пример использования_

```asm
.IFNDEF DEBUG_MODE
.DEFINE DEBUG_MODE 1
; Код, который выполняется только, если символ DEBUG_MODE не определен
    SET R1 0x01
    SET R2 0x02
    ; ...
.ENDIF

; Код, который будет выполняться всегда
    SET R3 0x03
    ; ...
```

В этом примере код внутри `IFNDEF` будет скомпилирован только один раз, даже если этот кусок кода будет добавлен несколько раз, например, через `INCLUDE`.
# 2. Директива .DEFINE

## Ассемблер теперь поддерживает директиву `.DEFINE`, которая позволяет определить константу (макрос). Определенный символ можно использовать в условных директивах, а также как непосредственное значение в операндах.
Синтаксис

`.DEFINE <символ> <значение>`

    `.DEFINE <символ> <значение>`:
        Определяет символ `<символ>` со значением `<значение>`.
        `<значение>` может быть целым числом в десятичной или шестнадцатеричной форме (0x...).

Пример использования
```asm
.DEFINE SCREEN_WIDTH 320
.DEFINE SCREEN_HEIGHT 240
.DEFINE OFFSET 0x10

SET R1 SCREEN_WIDTH ; Использования макроса
SET R2 SCREEN_HEIGHT
SET R3 OFFSET

.IFNDEF SCREEN_WIDTH
   SET R4 0x02 ; Эта строка не будет выполнена, потому что SCREEN_WIDTH определен
.ENDIF
```
## 3. Обработка условных директив в first_pass и compile

    first_pass:
        При первом проходе (сборка меток) компилятор теперь обрабатывает директивы .DEFINE, .IFNDEF, и .ENDIF для правильного вычисления размера программы и адресов меток. Код внутри блока .IFNDEF игнорируется, если символ определен.
    compile:
        При втором проходе (генерация машинного кода) компилятор использует флаг, управляемый .IFNDEF и .ENDIF, для включения или исключения фрагментов кода из окончательного машинного кода.
        Директива .DEFINE также обрабатывается на этапе компиляции, значения символов добавляются в таблицу констант.

## 4. Улучшенная обработка инструкций перехода

    Теперь ассемблер корректно обрабатывает инструкции перехода (JMP, JE, JNE, CALL), которые используют как метки, так и непосредственные адреса в качестве операндов.
    Компилятор теперь проверяет, что переход по непосредственному адресу происходит в пределах текущего банка.

## 5. Сортировка меток

    Вывод адресов меток теперь сортируется по возрастанию адреса, а не по имени метки. Это позволяет легче отслеживать их расположение в коде.

# Важные замечания

    Директивы `.IFNDEF` и `.ENDIF` могут быть вложенными.
    Директива `.DEFINE` должна быть определена до первого использования в `IFNDEF`.
    Компилятор выдаст ошибку, если директива .IFNDEF не будет закрыта директивой `.ENDIF`.
    Все директивы (`.INCLUDE`, `.IFNDEF`, `.ENDIF`, `.DEFINE`, `.DB`) и метки должны быть в верхнем регистре.


Надеюсь, эта документация будет тебе полезна!
